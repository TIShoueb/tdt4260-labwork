Welcome to the prefetcher exercise! No more mr. nice guy, we are actually going to mess with some more parts of gem5.

To set up this exercise, you need to download the following compressed archive https://s.ntnu.no/gem5-traces.
And then extract it to spec_cpts in the prefetcher/spec2017 (full path is src/tdt4260/prefetcher/spec2017/spec2017_cpts) folder. 
Other scripts rely on these being present in order to function.

For this exercise, you will be working in src/mem/cache/prefetch.
In here, you will find the files tdt_prefetcher.hh and tdt_prefetcher.cc.
Most of the work you will be doing, will be updating these ones, particularly the calculatePrefetch function, in which all AddrPriority you add to addresses will be prefetched by the system.
You might want to add more helper functions and structures, in which case you will have to modify the header file in addition to the cc file.

Whenever you have made changes to these files, you need to recompile the source code, by running `scons -j{x} build/X86/gem5.opt` (from the root of gem5), where {x} is how many threads you wanna use (2 if you use the virtual machine). 
You can then run all the spec2017 benchmarks and get important stats by invoking `python run_prefetcher.py` (from the prefetcher folder), which will run all benchmarks with a set configuration, and give you some useful stats in results/results_summary.txt. You can use this ipc to compare the efficiency of your implementation, and the detailed statistics to reason about why.


==HOW DOES THIS ALL WORK?==
The gem5 simulator takes a binary and emulates it as though it were running on a real system. 
Although it does not implement a real hardware architecture, it pretends it does, by passing instructions between various parts of the system, and emulating all behavior, including writing the right things to memory and so on.

What the run_prefetcher.py file does is use a preselected config (configs/tdt4260/prefetcher.py) and execute a selection of the spec2017 benchmarks, at a checkpointed location.
A checkpoint is a way to restore execution of a program from a specific part of program behavior, which lets us use more representative parts of the program rather than just the start.
It then simulates the out-of-order cpu with the memory system, and your implemented prefetcher for 10 million instructions (which is very little for research).
Afterwards, it compiles all the stats from the 4 benchmarks it has run.  

==SPEC2017==
Spec2017 is a selection of benchmarks that are meant to emulate the different type of high-stress work that modern processors typically do.
This is essentially a wide variety of typical performance tasks (i.e. actual tasks that strain the cpu) that are programmed to run for a long time.
The usage of this is running these programs to test various hardware configurations, or in our case, the performance impact of changing the architecture in a simulator. 

==CONFIG FILES==
The gem5 simulator uses configuration files to set up the simulated CPU and memory system.
For our purposes, we have configured ourselves according to the Ice Lake CPUs from Intel, with a matching memory system, based on their recent paper "Register File Prefetching". 
You can find the full configuration in configs/tdt4260/prefetcher.py. If you want to use multiple different prefetchers, you can also change this here.
Keep in mind that to use multiple different objects, you must also add it src/mem/cache/prefetcher/Cache.py and src/mem/cache/SConscript. 

==STAT FILES==
The stat files are the full amount of statistics generated by the gem5 simulator during execution.
As the TDTPrefetcher inherits from the base prefetcher, it gets some statistics by default.
You can also add more statistics yourself if you please, for an example of how this is done, look at src/mem/cache/prefetcher/base.hh.

